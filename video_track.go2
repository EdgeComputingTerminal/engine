package engine

import (
	"context"
	"log"
	"time"
	. "github.com/Monibuca/engine/v3/avformat"
)

const (
	fuaHeaderSize       = 2
	stapaHeaderSize     = 1
	stapaNALULengthSize = 2

	naluTypeBitmask   = 0x1F
	naluRefIdcBitmask = 0x60
	fuaStartBitmask   = 0x80 //1000 0000
	fuaEndBitmask     = 0x40 //0100 0000
)

type VideoPack struct {
	Timestamp uint
	Payload []byte //NALU
	NalType int
	SequenceNumber  uint16 
}
type VideoTrack struct {
	FirstScreen byte //最近的关键帧位置，首屏渲染
	Track[VideoPack]
	SPS []byte
	PPS []byte
	SPSInfo     SPSInfo
	GOP         int //关键帧间隔
	RtmpTag []byte //rtmp需要先发送一个序列帧，包含SPS和PPS
}

// Push 来自发布者推送的视频
func (vt *VideoTrack) Push(timestamp uint32, payload []byte) {
	payloadLen := len(payload)
	if payloadLen == 0 {
		return
	}
	video := vt.Buffer
	video.NalType := payload[0] & naluTypeBitmask
	video.Timestamp = timestamp
	
	video.IsKeyFrame = false
	video.SequenceNumber = vt.PacketCount

	switch video.NalType {
	case NALU_STAPA:
		for currOffset, naluSize := stapaHeaderSize, 0; currOffset < len(payload); currOffset += naluSize {
			naluSize = int(binary.BigEndian.Uint16(payload[currOffset:]))
			currOffset += stapaNALULengthSize
			if currOffset+len(payload) < currOffset+naluSize {
				Printf("STAP-A declared size(%d) is larger then buffer(%d)", naluSize, len(payload)-currOffset)
				return
			}
			vt.Push(timestamp, payload[currOffset:currOffset+naluSize])
		}
	case NALU_FUA:
		if len(payload) < fuaHeaderSize {
			Printf("Payload is not large enough to be FU-A")
			return
		}
		if payload[1]&fuaStartBitmask != 0 {
			naluRefIdc := payload[0] & naluRefIdcBitmask
			fragmentedNaluType := payload[1] & naluTypeBitmask
			video.Payload = append([]byte{}, payload...)
			video.Payload[fuaHeaderSize-1] = naluRefIdc | fragmentedNaluType
		} else {
			video.Payload = append(video.Payload, payload[fuaHeaderSize:]...)
		}
		if payload[1]&fuaEndBitmask != 0 {
			vt.Push(timestamp, video.Payload[fuaHeaderSize-1:])
		}
	case NALU_SPS:
		vt.SPS = payload
	case NALU_PPS:
		vt.PPS = payload
	case NALU_Access_Unit_Delimiter:

	case NALU_IDR_Picture:
		if vt.FirstScreen == nil {
			defer close(vt.WaitPub)
			vt.FirstScreen = video.SubRing(video.Index)
		} else {
			vt.GOP = video.Index - vt.FirstScreen.SequenceNumber
			vt.FirstScreen.GoTo(video.Index)
		}
		fallthrough
	case NALU_Non_IDR_Picture:
		video.Payload = payload
		vt.GetBPS(payloadLen)
		video.NextW()
	case NALU_SEI:
	default:
		Printf("nalType not support yet:%d", video.NalType)
	}
}


func (vt *VideoTrack) Play(ctx context.Context,callback func(VideoPack)) {
	ring :=vt.Buffer.SubRing(vt.FirstScreen)
	ring.Current.Wait()
	droped:=0
	var action func()
	drop := func(){
		if ring.Current.NalType == NALU_IDR_Picture {
			action = send
		} else {
			droped++
		}
	}
	send := func(){
		callback(ring.Current)
		pIndex := vt.Buffer.Index
		//s.BufferLength = pIndex - ring.Index
		//s.Delay = s.AVRing.Timestamp - packet.Timestamp
		if pIndex - ring.Index > 128 {
			action = drop
		}
	}
	for action =send;;ring.NextR() {
		select {
		case <-ctx.Done:
			return
		default:
			action()
		}
	}
}