package engine

import (
	"context"
	"log"
	"time"
)
type VideoPack struct {
	Timestamp uint
	Payload []byte //NALU
	IsKeyFrame bool//是否为关键帧
	SequenceNumber  uint16 
}
type VideoTrack struct {
	FirstScreen byte //最近的关键帧位置，首屏渲染
	Track[VideoPack]
	SPS []byte
	PPS []byte
	SPSInfo     SPSInfo
	GOP         int //关键帧间隔
	RtmpTag []byte //rtmp需要先发送一个序列帧，包含SPS和PPS
}

// Push 来自发布者推送的视频
func (vt *VideoTrack) Push(timestamp uint32, payload []byte) {
	payloadLen := len(payload)
	if payloadLen < 3 {
		return
	}
	video := r.Buffer
	video.Timestamp = timestamp
	video.Payload = payload
	video.IsKeyFrame = payload[0] & naluTypeBitmask == NALU_IDR_Picture
	video.SequenceNumber = vt.PacketCount

	if video.IsKeyFrame {
		if r.FirstScreen == nil {
			defer close(r.WaitPub)
			r.FirstScreen = video.SubRing(video.Index)
		} else {
			oldNumber := r.FirstScreen.SequenceNumber
			r.FirstScreen.GoTo(video.Index)
			r.GOP = r.FirstScreen.SequenceNumber - oldNumber
		}
	}
	vt.GetBPS(payloadLen)
	video.NextW()
}


func (vt *VideoTrack) Play(ctx context.Context,callback func(VideoPack)) {
	ring :=vt.Buffer.SubRing(vt.FirstScreen)
	ring.Current.Wait()
	droped:=0
	var action func()
	drop := func(){
		if ring.Current.IsKeyFrame {
			action = send
		} else {
			droped++
		}
	}
	send := func(){
		callback(ring.Current)
		pIndex := vt.Buffer.Index
		//s.BufferLength = pIndex - ring.Index
		//s.Delay = s.AVRing.Timestamp - packet.Timestamp
		if pIndex - ring.Index > 128 {
			action = drop
		}
	}
	for action =send;;ring.NextR() {
		select {
		case <-ctx.Done:
			return
		default:
			action()
		}
	}
}