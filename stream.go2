package engine

import (
	"context"
	"github.com/Monibuca/utils/v3/go2"
	"sync"
	"time"
	. "github.com/logrusorgru/aurora"
)

var streamCollection sync.Map

//FindStream 根据流路径查找流
func FindStream(streamPath string) *Stream {
	if s, ok := streamCollection.Load(streamPath); ok {
		return s.(*Stream)
	}
	return nil
}

//GetStream 根据流路径获取流，如果不存在则创建一个新的
func GetStream(streamPath string) (result *Stream) {
	item, loaded := streamCollection.LoadOrStore(streamPath, &Stream{
		StreamPath:     streamPath,
		HasVideo:       true,
		HasAudio:       true,
		EnableAudio:    &config.EnableAudio,
		EnableVideo:    &config.EnableVideo,
		WaitPub: make(chan struct{}),
	})
	result = item.(*Stream)
	if !loaded {
		result.Context, result.cancel = context.WithCancel(context.Background())
		if config.EnableVideo {
			result.EnableVideo = &result.HasVideo
		}
		if config.EnableAudio {
			result.EnableAudio = &result.HasAudio
		}
		Print(Green("Stream create:"), BrightCyan(streamPath))
	}
	return
}

// Stream 流定义
type Stream struct {
	context.Context
	cancel context.CancelFunc
	StreamPath     string 
	StartTime      time.Time //流的创建时间
	*Publisher
	Subscribers  []*Subscriber // 订阅者
	//VideoTag     *AVPacket              // 每个视频包都是这样的结构,区别在于Payload的大小.FMS在发送AVC sequence header,需要加上 VideoTags,这个tag 1个字节(8bits)的数据
	//AudioTag     *AVPacket              // 每个音频包都是这样的结构,区别在于Payload的大小.FMS在发送AAC sequence header,需要加上 AudioTags,这个tag 1个字节(8bits)的数据
	VideoTracks  []VideoTrack
	AudioTracks  []AudioTrack
	WaitPub      chan struct{}          //用于订阅和等待发布者
	HasAudio    bool
	HasVideo    bool
	EnableVideo *bool
	EnableAudio *bool
	subscribeMutex sync.Mutex
}

func (r *Stream) Close() {
	r.cancel()
	Print(Yellow("Stream destoryed :"), BrightCyan(r.StreamPath))
	streamCollection.Delete(r.StreamPath)
	TriggerHook(Hook{"StreamClose",r})
}

//Subscribe 订阅流
func (r *Stream) Subscribe(s *Subscriber) {
	if s.Stream = r;r.Err() == nil {
		s.SubscribeTime = time.Now()
		Print(Sprintf(Yellow("subscribe :%s %s,to Stream %s"), Blue(r.Type), Cyan(s.ID), BrightCyan(r.StreamPath)))
		s.Context, s.cancel = context.WithCancel(r)
		r.subscribeMutex.Lock()
		r.Subscribers = append(r.Subscribers,s)
		r.subscribeMutex.Unlock()
		Print(Sprintf(Yellow("%s subscriber %s added remains:%d"), BrightCyan(r.StreamPath), Cyan(s.ID), Blue(len(r.Subscribers))))
		TriggerHook(Hook{"Subscribe",s})
	}
}

//UnSubscribe 取消订阅流
func (r *Stream) UnSubscribe(s *Subscriber) {
	if r.Err() == nil {
		Print(Sprintf(Yellow("%s subscriber %s removed remains:%d"), BrightCyan(r.StreamPath), Cyan(s.ID), Blue(len(r.Subscribers))))
		r.subscribeMutex.Lock()
		go2.DeleteSliceItem[Subscriber](r.Subscribers,s)
		r.subscribeMutex.Unlock()
		TriggerHook(Hook{"UnSubscribe",s})
		if len(r.Subscribers) == 0 && (r.Publisher == nil || r.Publisher.AutoUnPublish) {
			r.Close()
		}
	}
}